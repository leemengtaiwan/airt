# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/ui.slack.ipynb.

# %% auto 0
__all__ = ['logger', 'NS', 'NP', 'P', 'GATHERING_PROMPT', 'STOP_PARSING', 'INTERMEDIATE_KEYS', 'get_key_val', 'parse_raw_text',
           'parse_rich_text_list', 'parse_rich_text', 'get_image_from_file', 'parse_app_mention_outer_event']

# %% ../../nbs/ui.slack.ipynb 3
import re
import os
import PIL
from PIL import Image
import requests
import io
import base64
import logging
from typing import List
from pprint import pprint, pformat


logger = logging.getLogger()
logger.setLevel(logging.INFO)

# %% ../../nbs/ui.slack.ipynb 5
def get_key_val(text: str, sep=":") -> dict:
    params = {}
    k, v = [s.strip() for s in text.split(sep)]

    # try:
    #     params[k] = int(v.replace(",", ''))
    # except ValueError:
    #     params[k] = v.replace(",", '')
        
    params[k] = v.replace(",", '')    
    
    return params

# %% ../../nbs/ui.slack.ipynb 6
def parse_raw_text(text: str) -> dict:

    text = re.sub("<@U.*>", "", text)

    params = {}
    # param_key_with_colons = re.findall("[\s,]\w*:\w*[\s,]", text)
    param_key_with_colons = re.findall("\w+:\s*\w+", text)
    n = len(param_key_with_colons)
    
    if n == 0 and text:
        params['prompt'] = text.strip()
    elif n > 0:
        remained_text = str(text)
        if n > 1:
            for i, p in enumerate(param_key_with_colons[:-1]):
                start = text.index(p)
                end = text.index(param_key_with_colons[i+1])
                partial_text = text[start: end]
                params.update(get_key_val(partial_text))
                remained_text = remained_text.replace(partial_text, "")
        
        start = text.index(param_key_with_colons[-1])
        end = start + len(param_key_with_colons[-1])
        partial_text = text[start: end]
        params.update(get_key_val(partial_text))
        remained_text = remained_text.replace(partial_text, "")
        
        params['prompt'] = remained_text.strip()
        
    else:
        raise NotImplementedError
    

    return params

# %% ../../nbs/ui.slack.ipynb 9
NS = "negative_sentences"
NP = "negative_prompt"
P = "prompt"

GATHERING_PROMPT = "gathering"
STOP_PARSING = "stop"
INTERMEDIATE_KEYS = [GATHERING_PROMPT, STOP_PARSING, NS]

# %% ../../nbs/ui.slack.ipynb 23
def parse_rich_text_list(element: dict) -> dict:
    if not (element['type'] == 'rich_text_list' and element['style'] == "bullet"):
        raise NotImplementedError(pformat(element))
    
    d = {}
    
    for e in element["elements"]:
        partial_d = parse_rich_text_section(e, is_bullet=True)
        d.update(partial_d)
    
    return d

# %% ../../nbs/ui.slack.ipynb 28
def parse_rich_text(element: dict, bot_user_id: str=None) -> dict:
    if not element['type'] == 'rich_text':
        raise NotImplementedError(pformat(element))
    
    d = {}
    for e in element['elements']:
        etype = e['type']
        
        if etype == 'rich_text_section':
            dd = parse_rich_text_section(e, bot_user_id=bot_user_id)
        elif etype == 'rich_text_list':
            dd = parse_rich_text_list(e)
        else:
            raise NotImplementedError(pformat(e))
        
        logger.info(f"Partial result from parsing {pformat(e)}:")
        logger.info(pformat(dd))
        
         # aggresive sstop
        if STOP_PARSING in dd:
            break
        
        for k, v in dd.items():
            if not k in d:
                d[k] = v
            elif k in d:
                if isinstance(d[k], list):
                    d[k].extend(v)
                else:
                    d[k] = v
                    
            else:
                raise NotImplementedError(f"partial result of {pformat(e)}: {pformat(dd)}")
            
    logger.info("Result by parsing `rich_text` element:")
    logger.info(pformat(d))
    return d
    
    

# %% ../../nbs/ui.slack.ipynb 36
def get_image_from_file(file: dict, token: str):
    # https://stackoverflow.com/a/39849014
    # https://stackoverflow.com/a/36221533
    ftype = file['filetype']
    if ftype != 'png':
        raise NotImplementedError(ftype)
    
    url = file['url_private']
    resp = requests.get(url, headers={'Authorization': 'Bearer %s' % token})
    if resp.status_code == 200:
        content = resp.content
        image = Image.open(io.BytesIO(content))
    else:
        logging.info(resp.status_code)
    
    return image

# %% ../../nbs/ui.slack.ipynb 41
def parse_app_mention_outer_event(outer_event: dict) -> dict:
    auth_info = outer_event['authorizations'][0]
    bot_user_id = auth_info['user_id']
    d = {}
    
    e = outer_event['event']
    if e['type'] != 'app_mention':
        raise NotImplementedError(pformat(e))
    
    for b in e['blocks']:
        if b['type'] != 'rich_text':
            raise NotImplementedError(pformat(b))
        
        dd = parse_rich_text(b, bot_user_id=bot_user_id)
        logger.info(f"Result from parsing block: {pformat(b)}")
        logger.info(pformat(dd))
        
        d.update(dd)
    
    for k in INTERMEDIATE_KEYS:
        if k == NS and k in d:
            logging.info(d[NS])
            d[NP] = " ".join(d[NS])
            
        d.pop(k, None)
        
    orig_d = dict(d)
    for k, v in orig_d.items():
        try:
            d[k] = int(v)

        except ValueError:
            try:
                d[k] = float(v)
            except ValueError:
                continue
                
    # image
    files = e.get('files', [])
    if files:
        logger.info("File detected, try downloading.")
        if len(files) > 1:
            logger.info(f"{len(files)} detected. only use first file as image")
        
        file = files[0]
        token = os.environ['SLACK_BOT_TOKEN']
        image: PIL.PngImagePlugin.PngImageFile = get_image_from_file(file, token=token)
        d['init_image'] = image                 
    
    return d
